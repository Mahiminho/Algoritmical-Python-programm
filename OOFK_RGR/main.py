def task1(num):

    print("Тема: 1. ЗНАЙДІТЬ ПРАВИЛЬНУ ВІДПОВІДЬ:")
    print("")

    questions = {
        "З якого боку від коми розміщені позиції цифр, які мають вагу, що дорівнює числу 10 в додатній степені?" : "а) праворуч;",
        "Що прийнято називати основою системи числення:" : "б) кількість символів, що використовується в системі числення;",
        "Яку дію потрібно виконати для визначення “ваги” даного розряду числа до загальної його величини?" : "в) перемножити номер розряду і значення цифри, яка в ньому знаходиться;",
        "Що є основою двійкової системи числення?" : "е) 10[2];",
        "Яке з двох чисел більше: 11112 або 1110?" : "Якщо в умові немає помилки, то звісно ж 11112.",
        "Яку операцію необхідно виконати при перетворенні цілої частини числа з однєї системи числення до іншої?" : "г) ділення;",
        "Яку операцію необхідно виконати при перетворенні дробової частини числа з однєї системи числення до іншої?" : "в) множення;",
        "До якої кількості символів скорочується двійковий запис байта при використанні вісімкових символів?" : "б) 3;",
        "До якої кількості символів скорочується двійковий запис двобайтового числа при використанні шістнадцяткових символів?" : "г) 4;",
        "У скільки разів зменшується довжина запису чисел при переході від двійкової системи представлення до шістнадцяткової?" : "в) 4;",
        "Звідки починається розбиття на тріади двійкового числа при його переведенні до вісімкової системи?" : "б) від молодшого вагового розряду;",
        "Чим відрізняються двійкові числа 1012; 01012 і 0000 01012? Як це може вплинути на результат двійкового сумування?" : "в) числа рівні;",
        "Яка максимальна кількість розрядів необхідна для представлення результату додавання двох 8-розрядних чисел?" : "а) 9;",
        "Які символи використовуються у вісімковій системі числення?" : "г) 0 : 7",
        "Яку кількість різних десяткових чисел можна представити 8-розрядним двійковим числом?" : "б) 256;",
        "Які символи використовуються у шістнадцятковій системі числення?" : "г) 0 : F;",
        "Які символи використовуються у двійковій системі числення?" : "в) 0 : 1;",
        "Яка максимальна кількість розрядів необхідна для представлення результату додавання двох 10-розрядних чисел?" : "б) 11;",
        "Яке мнемонічне позначення має команда арифметичного додавання у навчальній програмі DeComp?" : "г) ADD;",
        "Яке мнемонічне позначення має команда арифметичного віднімання у навчальній програмі DeComp?" : "в) SUB;",
        "Сигнали, які відображають обмежену кількість фіксованих станів об’єкта чи процесу і на скінченному інтервалі параметрів набувають обмеженої кількості їхніх значень називають:" : "б) дискретними;",
        "Скінчена множина символів, за допомогою якої подається інформація про певний об’єкт, називається;" : "в) алфавіт;",
        "Впорядкована послідовність скінченої кількості символів, називається:" : "г) слово;",
        "Універсальний спосіб відображення дискретної інформації під час її зберігання, передавання та опрацювання у вигляді системи відповідностей між елементами повідомлень" : "а) код;",
        "Матеріальний носій інформації, який має певні фізичні властивості, називається;" : "б) сигнал;",
        "Інформація, яка подана у формалізованому вигляді, для інформаційних технологій, як правило, за допомогою букв, цифр чи певних символів." : "а) дані;",
        "Дані, які передаються джерелом інформації або ті, що отримані приймачем, називаються:" : "в) повідомлення;",
        "Логічна операція «АБО» позначається як:" : "а) OR;",
        "Логічна операція «І» позначається як:" : "б) AND;",
        "Логічна операція «ЗАПЕРЕЧЕННЯ» позначається як:" : "г) NOT;"
    }

    print(num)
    print("Відповідь: " + questions[num])
    print("")
    print("")
    print("")





























def task2(num):
    print("Тема: 2. ВИЗНАЧИТИ ДЕСЯТКОВІ ЗНАЧЕННЯ ЗАДАНИХ ЧИСЕЛ:")
    print("")
    print("ПОПЕРЕДЖЕННЯ: Увага! У квадратних дужках позначається система числення! Не переписуйте квадратних дужок, просто система числення пишеться меншими цифрами!")
    print("")
    print("ПОЯСНЕННЯ: Щоб перевести число з будь-якої системи числення у десяткову, потрібно 'вагу' кожного розряду помножити на номер цього розряду.")
    print("")

    nums = num.split(" ")
    a = nums[0]
    b = nums[1]
    c = nums[2]




    # ДЛЯ ПЕРШОГО ЧИСЛА
    # ДЛЯ ПЕРШОГО ЧИСЛА
    # ДЛЯ ПЕРШОГО ЧИСЛА
    a_divided = a.split(",") # розбиваю перше число з основою вісім на дві частини: цілу (до коми) і дробову (після коми)
    a_before_coma = list(a_divided[0]) # роблю масив з цілого числа
    a_after_coma = list(a_divided[1]) # роблю масив з дробового числа

    a_before_coma = [int(item) for item in a_before_coma] # переводжу масив з чисел до коми в числа з рядків
    a_after_coma = [int(item) for item in a_after_coma] # переводжу масив з чисел після коми в числа з рядків
    a_before_coma.reverse() # перевернув список чисел до коми, щоб виконати дії у правильному порядку

    # РАХУЮ СУМУ ДО КОМИ
    res1 = 0
    i = 0
    while i < len(a_before_coma):
        res1 += a_before_coma[i] * 8 ** i
        i += 1

    # РАХУЮ СУМУ ПІСЛЯ КОМИ
    res2 = 0
    i = 0
    p = -1
    while i < len(a_after_coma):
        res2 += a_after_coma[i] * 8 ** p
        i += 1
        p -= 1

    full_res = res1 + res2 # рахую повну суму

    a_before_coma.reverse()  # ще раз перевернув список чисел до коми, щоб записати в строку в правильному порядку
    str_full_res = ""

    # СТВОРЕННЯ ПЕРШОЇ ЧАСТИНИ ВИРАЗУ (ДО КОМИ)
    i = 0
    l = len(a_before_coma) - 1
    while i < len(a_before_coma):
        mid = str(a_before_coma[i]) + "*8^" + "(" + str(l) + ")" + " + "
        str_full_res += mid
        i += 1
        l -= 1

    # СТВОРЕННЯ ДРУГОЇ ЧАСТИНИ ВИРАЗУ (ПІСЛЯ КОМИ)
    s = -1
    i = 0
    while i < len(a_after_coma):
        mid = str(a_after_coma[i]) + "*8^" + "(" + str(s) + ")" + " + "
        str_full_res += mid
        i += 1
        s -= 1

    # ДОВЕРШЕННЯ ВИРАЗУ
    str_full_res = str_full_res[:-1]
    str_full_res = str_full_res[:-1]
    str_full_res = a + "[8] = " + str_full_res + "= " + str(full_res) + "[10]"

    print(str_full_res, "\n")










    # ДЛЯ ДРУГОГО ЧИСЛА
    # ДЛЯ ДРУГОГО ЧИСЛА
    # ДЛЯ ДРУГОГО ЧИСЛА
    b_divided = b.split(",")  # розбиваю друге число з основою п`ять на дві частини: цілу (до коми) і дробову (після коми)
    b_before_coma = list(b_divided[0])  # роблю масив з цілого числа
    b_after_coma = list(b_divided[1])  # роблю масив з дробового числа

    b_before_coma = [int(item) for item in b_before_coma]  # переводжу масив з чисел до коми в числа з рядків
    b_after_coma = [int(item) for item in b_after_coma]  # переводжу масив з чисел після коми в числа з рядків
    b_before_coma.reverse()  # перевернув список чисел до коми, щоб виконати дії у правильному порядку

    # РАХУЮ СУМУ ДО КОМИ
    res1 = 0
    i = 0
    while i < len(b_before_coma):
        res1 += b_before_coma[i] * 5 ** i
        i += 1

    # РАХУЮ СУМУ ПІСЛЯ КОМИ
    res2 = 0
    i = 0
    p = -1
    while i < len(b_after_coma):
        res2 += b_after_coma[i] * 5 ** p
        i += 1
        p -= 1

    full_res = res1 + res2  # рахую повну суму

    b_before_coma.reverse()  # ще раз перевернув список чисел до коми, щоб записати в строку в правильному порядку
    str_full_res = ""

    # СТВОРЕННЯ ПЕРШОЇ ЧАСТИНИ ВИРАЗУ (ДО КОМИ)
    i = 0
    l = len(b_before_coma) - 1
    while i < len(b_before_coma):
        mid = str(b_before_coma[i]) + "*5^" + "(" + str(l) + ")" + " + "
        str_full_res += mid
        i += 1
        l -= 1

    # СТВОРЕННЯ ДРУГОЇ ЧАСТИНИ ВИРАЗУ (ПІСЛЯ КОМИ)
    s = -1
    i = 0
    while i < len(b_after_coma):
        mid = str(b_after_coma[i]) + "*5^" + "(" + str(s) + ")" + " + "
        str_full_res += mid
        i += 1
        s -= 1

    # ДОВЕРШЕННЯ ВИРАЗУ
    str_full_res = str_full_res[:-1]
    str_full_res = str_full_res[:-1]
    str_full_res = b + "[5] = " + str_full_res + "= " + str(full_res) + "[10]"

    print(str_full_res, "\n")









    # ДЛЯ ТРЕТЬОГО ЧИСЛА
    # ДЛЯ ТРЕТЬОГО ЧИСЛА
    # ДЛЯ ТРЕТЬОГО ЧИСЛА
    c_divided = c.split(",")  # розбиваю третє число з основою два на дві частини: цілу (до коми) і дробову (після коми)
    c_before_coma = list(c_divided[0])  # роблю масив з цілого числа
    c_after_coma = list(c_divided[1])  # роблю масив з дробового числа

    c_before_coma = [int(item) for item in c_before_coma]  # переводжу масив з чисел до коми в числа з рядків
    c_after_coma = [int(item) for item in c_after_coma]  # переводжу масив з чисел після коми в числа з рядків
    c_before_coma.reverse()  # перевернув список чисел до коми, щоб виконати дії у правильному порядку

    # РАХУЮ СУМУ ДО КОМИ
    res1 = 0
    i = 0
    while i < len(c_before_coma):
        res1 += c_before_coma[i] * 2 ** i
        i += 1

    # РАХУЮ СУМУ ПІСЛЯ КОМИ
    res2 = 0
    i = 0
    p = -1
    while i < len(c_after_coma):
        res2 += c_after_coma[i] * 5 ** p
        i += 1
        p -= 1

    full_res = res1 + res2  # рахую повну суму

    c_before_coma.reverse()  # ще раз перевернув список чисел до коми, щоб записати в строку в правильному порядку
    str_full_res = ""

    # СТВОРЕННЯ ПЕРШОЇ ЧАСТИНИ ВИРАЗУ (ДО КОМИ)
    i = 0
    l = len(c_before_coma) - 1
    while i < len(c_before_coma):
        mid = str(c_before_coma[i]) + "*2^" + "(" + str(l) + ")" + " + "
        str_full_res += mid
        i += 1
        l -= 1

    # СТВОРЕННЯ ДРУГОЇ ЧАСТИНИ ВИРАЗУ (ПІСЛЯ КОМИ)
    s = -1
    i = 0
    while i < len(c_after_coma):
        mid = str(c_after_coma[i]) + "*2^" + "(" + str(s) + ")" + " + "
        str_full_res += mid
        i += 1
        s -= 1

    # ДОВЕРШЕННЯ ВИРАЗУ
    str_full_res = str_full_res[:-1]
    str_full_res = str_full_res[:-1]
    str_full_res = c + "[2] = " + str_full_res + "= " + str(full_res) + "[10]"

    print(str_full_res)
    print("")
    print("")
    print("")














def task3(num):
    print("Тема: 3. ЗАДАНІ ДЕСЯТКОВІ ЧИСЛА ПЕРЕТВОРИТИ У ДВІЙКОВІ, ВІСІМКОВІ ТА ШІСТНАДЦЯТКОВІ: (у дробових частинах чисел досягти точності до 1-го байта).")
    print("")
    print("ПОПЕРЕДЖЕННЯ: Увага! У квадратних дужках позначається система числення! Не переписуйте квадратних дужок, просто система числення пишеться меншими цифрами!")
    print("")
    print("ПОЯСНЕННЯ: Щоб перевести ціле число з десяткової системи числення у n-ову, потрібно ділити його на n доти, доки воно не стане рівне 0. Дробову частину потрібно множити на n доти, в залежності від того, скільки знаків після коми нам потрібно.")
    print("")

    nums = num.split(" ")
    a = nums[0]
    b = nums[1]




    # ДЛЯ ПЕРШОГО ЧИСЛА
    # ДЛЯ ПЕРЕВЕДЕННЯ В ДВІЙКОВУ СИСТЕМУ ЧИСЛЕННЯ
    print("1) Переведення першого числа з десяткової системи числення у двійкову:\n")
    a_divided = a.split(",") # розбиваю перше число з основою десять на дві частини: цілу (до коми) і дробову (після коми)
    a_before_coma = int(a_divided[0]) # роблю ціле число, з числа до коми
    a_after_coma = int(a_divided[1]) # роблю ціле число з числа після коми



    for_user1 = [] # порожній масив де будуть числа ділені на 2, для виведення їх юзеру
    res1 = a_before_coma % 2 # по модулю знаходжу останню цифру відповіді (тобто фінального двійкового числа до коми)
    res2 = a_before_coma // 2 # ділю без остачі (для наступного ділення по модулю)
    for_user1.append(a_before_coma) # додаю в масив число
    full_res1 = [] # створюю пустий масив з відповіддю (перевернутою)
    full_res1.append(str(res1)) # додаю останню цифру відповіді в масив
    while res2 >= 1: # повторюю дії до кінця
        for_user1.append(res2)
        res1 = res2 % 2
        res2 = res2 // 2
        full_res1.append(str(res1))




    half_res = "0." + str(a_after_coma) # роблю дробове число після коми строкою
    half_res = float(half_res) # переводжу його в НЕ цілочисельний формат

    for_user2 = [] # порожній масив де будуть числа множені на 2, для виведення їх юзеру
    for_user2.append(round(half_res, 3)) # заокруглення (до трьох знаків після коми) чисел, множених на 2 і додання їх в масив
    i = 0
    full_res2 = [] # створюю масив для відповіді
    res3 = half_res * 2 # виконую першу дію множення

    if res3 >= 1: # і першу перевірку (якщо після множення число більше рівне за один, то додаємо в масив 1, інакше нуль)
        full_res2.append('1')
        res3 -= 1
    else: # протилежний варіает першої перевірки
        full_res2.append('0')

    while i < 7: # продовжую перевірки, заповнюючи масив одиницями і нулями
        for_user2.append(round(res3, 3))
        res3 = res3 * 2

        if res3 >= 1:
            full_res2.append('1')
            res3 -= 1
        else:
            full_res2.append('0')
        i += 1




    i = 0
    while i < len(for_user1): # створення виразів для користувача, які він записуватиме (з числом до коми)
        mid = "(" + str(full_res1[i]) + ")"
        print(str(for_user1[i]), ": 2 =", for_user1[i] // 2, mid)
        i += 1

    print("")

    i = 0
    while i < len(for_user2): # створення виразів для користувача, які він записуватиме (з числом після коми)
        res = for_user2[i] * 2

        if res >= 1:
            res -= 1
        else:
            pass

        mid = str(for_user2[i]) + " * 2 = " + str(round(res, 3)) + " (" + str(full_res2[i]) + ")"
        print(mid)
        i += 1

    print("")



    full_res1.reverse() # перевертаю масив, щоб числа для відповіді були в правильному порядку
    full_res1 = ''.join(full_res1) # зробив з масива строку до коми
    full_res2 = ''.join(full_res2) # зробив з масива строку після коми
    full_res = full_res1 + "," + full_res2 # формую фінальне число результат




    final = a + "[10] = " + str(full_res) + "[2]" # формую фінальну строку з відповіддю переведення
    print(final)
    print("")









    # ДЛЯ ПЕРШОГО ЧИСЛА
    # ДЛЯ ПЕРЕВЕДЕННЯ В ВІСІМКОВУ СИСТЕМУ ЧИСЛЕННЯ
    print("2) Переведення першого числа з десяткової системи числення у вісімкову:\n")
    a_divided = a.split(",") # розбиваю перше число з основою десять на дві частини: цілу (до коми) і дробову (після коми)
    a_before_coma = int(a_divided[0]) # роблю ціле число, з числа до коми
    a_after_coma = int(a_divided[1]) # роблю ціле число з числа після коми



    for_user1 = [] # порожній масив де будуть числа ділені на 8, для виведення їх юзеру
    res1 = a_before_coma % 8 # по модулю знаходжу останню цифру відповіді (тобто фінального вісімкового числа до коми)
    res2 = a_before_coma // 8 # ділю без остачі (для наступного ділення по модулю)
    for_user1.append(a_before_coma) # додаю в масив число
    full_res1 = [] # створюю пустий масив з відповіддю (перевернутою)
    full_res1.append(str(res1)) # додаю останню цифру відповіді в масив
    while res2 >= 1: # повторюю дії до кінця
        for_user1.append(res2)
        res1 = res2 % 8
        res2 = res2 // 8
        full_res1.append(str(res1))




    half_res = "0." + str(a_after_coma) # роблю дробове число після коми строкою
    half_res = float(half_res) # переводжу його в НЕ цілочисельний формат

    for_user2 = [] # порожній масив де будуть числа множені на 8, для виведення їх юзеру
    for_user2.append(round(half_res, 3)) # заокруглення (до трьох знаків після коми) чисел, множених на 8 і додання їх в масив
    i = 0
    full_res2 = [] # створюю масив для відповіді
    res3 = half_res * 8 # виконую першу дію множення

    if res3 >= 1: # і першу перевірку: якщо число більше рівне за 1, то:
        res_half = str(res3) # переводжу його в строку
        res_half = res_half.split(".") # розбива по крапці на дві частини: до і після крапки
        first = int(res_half[0]) # першу частину (до крапки (тобто цілу)) переводжу в цілочисельний формат
        res3 -= first # віднімаю від основного так би мовити числа (яке множиться) цілу частину
        full_res2.append(str(first)) # додаю в масив строкою
    else: # протилежний варіант першої перевірки
        full_res2.append('0')

    while i < 7: # продовжую перевірки, заповнюючи масив числами
        for_user2.append(round(res3, 3))
        res3 = res3 * 8

        if res3 >= 1:
            res_half = str(res3)
            res_half = res_half.split(".")
            first = int(res_half[0])
            res3 -= first
            full_res2.append(str(first))
        else:
            full_res2.append('0')
        i += 1




    i = 0
    while i < len(for_user1): # створення виразів для користувача, які він записуватиме (з числом до коми)
        mid = "(" + str(full_res1[i]) + ")"
        print(str(for_user1[i]), ": 8 =", for_user1[i] // 8, mid)
        i += 1

    print("")

    i = 0
    while i < len(for_user2): # створення виразів для користувача, які він записуватиме (з числом після коми)
        res = for_user2[i] * 8

        if res >= 1:
            res_half = str(res)
            res_half = res_half.split(".")
            first = int(res_half[0])
            res -= first
        else:
            pass

        mid = str(for_user2[i]) + " * 8 = " + str(round(res, 3)) + " (" + str(full_res2[i]) + ")"
        print(mid)
        i += 1

    print("")



    full_res1.reverse() # перевертаю масив, щоб числа для відповіді були в правильному порядку
    full_res1 = ''.join(full_res1) # зробив з масива строку до коми
    full_res2 = ''.join(full_res2) # зробив з масива строку після коми
    full_res = full_res1 + "," + full_res2 # формую фінальне число результат




    final = a + "[10] = " + str(full_res) + "[8]" # формую фінальну строку з відповіддю переведення
    print(final)
    print("")









    # ДЛЯ ПЕРШОГО ЧИСЛА
    # ДЛЯ ПЕРЕВЕДЕННЯ В ШІСТНАДЦЯТКОВУ СИСТЕМУ ЧИСЛЕННЯ
    more10 = {10:"A", 11:"B", 12:"C", 13:"D", 14:"E", 15:"F"} # словник, де числа, більші за 10 в шістнадцятковій

    print("3) Переведення першого числа з десяткової системи числення у шістнадцяткову:\n")
    a_divided = a.split(",") # розбиваю перше число з основою десять на дві частини: цілу (до коми) і дробову (після коми)
    a_before_coma = int(a_divided[0]) # роблю ціле число, з числа до коми
    a_after_coma = int(a_divided[1]) # роблю ціле число з числа після коми



    for_user1 = [] # порожній масив де будуть числа ділені на 16, для виведення їх юзеру
    res1 = a_before_coma % 16 # по модулю знаходжу останню цифру відповіді (тобто фінального вісімкового числа до коми)
    res2 = a_before_coma // 16 # ділю без остачі (для наступного ділення по модулю)
    for_user1.append(a_before_coma) # додаю в масив число
    full_res1 = [] # створюю пустий масив з відповіддю (перевернутою)
    if res1 >= 10: # перевірка, якщо остача більша рівна за 10, то перетворюємо її в букву
        res1 = more10[res1]
    full_res1.append(str(res1)) # додаю останню цифру (чи букву) відповіді в масив
    while res2 >= 1: # повторюю дії до кінця
        for_user1.append(res2)
        res1 = res2 % 16
        res2 = res2 // 16
        if res1 >= 10:
            res1 = more10[res1]
        full_res1.append(str(res1))




    half_res = "0." + str(a_after_coma) # роблю дробове число після коми строкою
    half_res = float(half_res) # переводжу його в НЕ цілочисельний формат

    for_user2 = [] # порожній масив де будуть числа множені на 16, для виведення їх юзеру
    for_user2.append(round(half_res, 3)) # заокруглення (до трьох знаків після коми) чисел, множених на 16 і додання їх в масив
    i = 0
    full_res2 = [] # створюю масив для відповіді
    res3 = half_res * 16 # виконую першу дію множення

    if res3 >= 1: # і першу перевірку: якщо число більше рівне за 1, то:
        res_half = str(res3) # переводжу його в строку
        res_half = res_half.split(".") # розбива по крапці на дві частини: до і після крапки
        first = int(res_half[0]) # першу частину (до крапки (тобто цілу)) переводжу в цілочисельний формат
        res3 -= first # віднімаю від основного, так би мовити числа (яке множиться), цілу частину
        if first >= 10: # перевірка чи остача більша рівна за 10, тоді заміняємо її буквою
            first = more10[first]
        full_res2.append(str(first)) # додаю в масив строкою
    else: # протилежний варіант першої перевірки
        full_res2.append('0')

    while i < 7: # продовжую перевірки, заповнюючи масив числами
        for_user2.append(round(res3, 3))
        res3 = res3 * 16

        if res3 >= 1:
            res_half = str(res3)
            res_half = res_half.split(".")
            first = int(res_half[0])
            res3 -= first
            if first >= 10:
                first = more10[first]
            full_res2.append(str(first))
        else:
            full_res2.append('0')
        i += 1




    i = 0
    while i < len(for_user1): # створення виразів для користувача, які він записуватиме (з числом до коми)
        mid = "(" + str(full_res1[i]) + ")"
        print(str(for_user1[i]), ": 16 =", for_user1[i] // 16, mid)
        i += 1

    print("")

    i = 0
    while i < len(for_user2): # створення виразів для користувача, які він записуватиме (з числом після коми)
        res = for_user2[i] * 16

        if res >= 1:
            res_half = str(res)
            res_half = res_half.split(".")
            first = int(res_half[0])
            res -= first
        else:
            pass

        mid = str(for_user2[i]) + " * 16 = " + str(round(res, 3)) + " (" + str(full_res2[i]) + ")"
        print(mid)
        i += 1

    print("")



    full_res1.reverse() # перевертаю масив, щоб числа для відповіді були в правильному порядку
    full_res1 = ''.join(full_res1) # зробив з масива строку до коми
    full_res2 = ''.join(full_res2) # зробив з масива строку після коми
    full_res = full_res1 + "," + full_res2 # формую фінальне число результат




    final = a + "[10] = " + str(full_res) + "[16]" # формую фінальну строку з відповіддю переведення
    print(final)
    print("")











    # ДЛЯ ДРУГОГО ЧИСЛА
    # ДЛЯ ПЕРЕВЕДЕННЯ В ДВІЙКОВУ СИСТЕМУ ЧИСЛЕННЯ
    print("4) Переведення другого числа з десяткової системи числення у двійкову:\n")
    b_divided = b.split(",") # розбиваю друге число з основою десять на дві частини: цілу (до коми) і дробову (після коми)
    b_before_coma = int(b_divided[0]) # роблю ціле число, з числа до коми
    b_after_coma = int(b_divided[1]) # роблю ціле число з числа після коми



    for_user1 = [] # порожній масив де будуть числа ділені на 2, для виведення їх юзеру
    res1 = b_before_coma % 2 # по модулю знаходжу останню цифру відповіді (тобто фінального двійкового числа до коми)
    res2 = b_before_coma // 2 # ділю без остачі (для наступного ділення по модулю)
    for_user1.append(b_before_coma) # додаю в масив число
    full_res1 = [] # створюю пустий масив з відповіддю (перевернутою)
    full_res1.append(str(res1)) # додаю останню цифру відповіді в масив
    while res2 >= 1: # повторюю дії до кінця
        for_user1.append(res2)
        res1 = res2 % 2
        res2 = res2 // 2
        full_res1.append(str(res1))




    half_res = "0." + str(b_after_coma) # роблю дробове число після коми строкою
    half_res = float(half_res) # переводжу його в НЕ цілочисельний формат

    for_user2 = [] # порожній масив де будуть числа множені на 2, для виведення їх юзеру
    for_user2.append(round(half_res, 3)) # заокруглення (до трьох знаків після коми) чисел, множених на 2 і додання їх в масив
    i = 0
    full_res2 = [] # створюю масив для відповіді
    res3 = half_res * 2 # виконую першу дію множення

    if res3 >= 1: # і першу перевірку (якщо після множення число більше рівне за один, то додаємо в масив 1, інакше нуль)
        full_res2.append('1')
        res3 -= 1
    else: # протилежний варіант першої перевірки
        full_res2.append('0')

    while i < 7: # продовжую перевірки, заповнюючи масив одиницями і нулями
        for_user2.append(round(res3, 3))
        res3 = res3 * 2

        if res3 >= 1:
            full_res2.append('1')
            res3 -= 1
        else:
            full_res2.append('0')
        i += 1




    i = 0
    while i < len(for_user1): # створення виразів для користувача, які він записуватиме (з числом до коми)
        mid = "(" + str(full_res1[i]) + ")"
        print(str(for_user1[i]), ": 2 =", for_user1[i] // 2, mid)
        i += 1

    print("")

    i = 0
    while i < len(for_user2): # створення виразів для користувача, які він записуватиме (з числом після коми)
        res = for_user2[i] * 2

        if res >= 1:
            res -= 1
        else:
            pass

        mid = str(for_user2[i]) + " * 2 = " + str(round(res, 3)) + " (" + str(full_res2[i]) + ")"
        print(mid)
        i += 1

    print("")



    full_res1.reverse() # перевертаю масив, щоб числа для відповіді були в правильному порядку
    full_res1 = ''.join(full_res1) # зробив з масива строку до коми
    full_res2 = ''.join(full_res2) # зробив з масива строку після коми
    full_res = full_res1 + "," + full_res2 # формую фінальне число результат




    final = b + "[10] = " + str(full_res) + "[2]" # формую фінальну строку з відповіддю переведення
    print(final)
    print("")









    # ДЛЯ ДРУГОГО ЧИСЛА
    # ДЛЯ ПЕРЕВЕДЕННЯ В ВІСІМКОВУ СИСТЕМУ ЧИСЛЕННЯ
    print("5) Переведення другого числа з десяткової системи числення у вісімкову:\n")
    b_divided = b.split(",") # розбиваю друге число з основою десять на дві частини: цілу (до коми) і дробову (після коми)
    b_before_coma = int(b_divided[0]) # роблю ціле число, з числа до коми
    b_after_coma = int(b_divided[1]) # роблю ціле число з числа після коми



    for_user1 = [] # порожній масив де будуть числа ділені на 8, для виведення їх юзеру
    res1 = b_before_coma % 8 # по модулю знаходжу останню цифру відповіді (тобто фінального вісімкового числа до коми)
    res2 = b_before_coma // 8 # ділю без остачі (для наступного ділення по модулю)
    for_user1.append(b_before_coma) # додаю в масив число
    full_res1 = [] # створюю пустий масив з відповіддю (перевернутою)
    full_res1.append(str(res1)) # додаю останню цифру відповіді в масив
    while res2 >= 1: # повторюю дії до кінця
        for_user1.append(res2)
        res1 = res2 % 8
        res2 = res2 // 8
        full_res1.append(str(res1))




    half_res = "0." + str(b_after_coma) # роблю дробове число після коми строкою
    half_res = float(half_res) # переводжу його в НЕ цілочисельний формат

    for_user2 = [] # порожній масив де будуть числа множені на 8, для виведення їх юзеру
    for_user2.append(round(half_res, 3)) # заокруглення (до трьох знаків після коми) чисел, множених на 8 і додання їх в масив
    i = 0
    full_res2 = [] # створюю масив для відповіді
    res3 = half_res * 8 # виконую першу дію множення

    if res3 >= 1: # і першу перевірку: якщо число більше рівне за 1, то:
        res_half = str(res3) # переводжу його в строку
        res_half = res_half.split(".") # розбиваю по крапці на дві частини: до і після крапки
        first = int(res_half[0]) # першу частину (до крапки (тобто цілу)) переводжу в цілочисельний формат
        res3 -= first # віднімаю від основного так би мовити числа (яке множиться) цілу частину
        full_res2.append(str(first)) # додаю в масив строкою
    else: # протилежний варіант першої перевірки
        full_res2.append('0')

    while i < 7: # продовжую перевірки, заповнюючи масив числами
        for_user2.append(round(res3, 3))
        res3 = res3 * 8

        if res3 >= 1:
            res_half = str(res3)
            res_half = res_half.split(".")
            first = int(res_half[0])
            res3 -= first
            full_res2.append(str(first))
        else:
            full_res2.append('0')
        i += 1




    i = 0
    while i < len(for_user1): # створення виразів для користувача, які він записуватиме (з числом до коми)
        mid = "(" + str(full_res1[i]) + ")"
        print(str(for_user1[i]), ": 8 =", for_user1[i] // 8, mid)
        i += 1

    print("")

    i = 0
    while i < len(for_user2): # створення виразів для користувача, які він записуватиме (з числом після коми)
        res = for_user2[i] * 8

        if res >= 1:
            res_half = str(res)
            res_half = res_half.split(".")
            first = int(res_half[0])
            res -= first
        else:
            pass

        mid = str(for_user2[i]) + " * 8 = " + str(round(res, 3)) + " (" + str(full_res2[i]) + ")"
        print(mid)
        i += 1

    print("")



    full_res1.reverse() # перевертаю масив, щоб числа для відповіді були в правильному порядку
    full_res1 = ''.join(full_res1) # зробив з масива строку до коми
    full_res2 = ''.join(full_res2) # зробив з масива строку після коми
    full_res = full_res1 + "," + full_res2 # формую фінальне число результат




    final = b + "[10] = " + str(full_res) + "[8]" # формую фінальну строку з відповіддю переведення
    print(final)
    print("")









    # ДЛЯ ДРУГОГО ЧИСЛА
    # ДЛЯ ПЕРЕВЕДЕННЯ В ШІСТНАДЦЯТКОВУ СИСТЕМУ ЧИСЛЕННЯ
    more10 = {10:"A", 11:"B", 12:"C", 13:"D", 14:"E", 15:"F"} # словник, де числа, більші за 10 в шістнадцятковій

    print("6) Переведення другого числа з десяткової системи числення у шістнадцяткову:\n")
    b_divided = b.split(",") # розбиваю друге число з основою десять на дві частини: цілу (до коми) і дробову (після коми)
    b_before_coma = int(b_divided[0]) # роблю ціле число, з числа до коми
    b_after_coma = int(b_divided[1]) # роблю ціле число з числа після коми



    for_user1 = [] # порожній масив де будуть числа ділені на 16, для виведення їх юзеру
    res1 = b_before_coma % 16 # по модулю знаходжу останню цифру відповіді (тобто фінального вісімкового числа до коми)
    res2 = b_before_coma // 16 # ділю без остачі (для наступного ділення по модулю)
    for_user1.append(b_before_coma) # додаю в масив число
    full_res1 = [] # створюю пустий масив з відповіддю (перевернутою)
    if res1 >= 10: # перевірка, якщо остача більша рівна за 10, то перетворюємо її в букву
        res1 = more10[res1]
    full_res1.append(str(res1)) # додаю останню цифру (чи букву) відповіді в масив
    while res2 >= 1: # повторюю дії до кінця
        for_user1.append(res2)
        res1 = res2 % 16
        res2 = res2 // 16
        if res1 >= 10:
            res1 = more10[res1]
        full_res1.append(str(res1))




    half_res = "0." + str(b_after_coma) # роблю дробове число після коми строкою
    half_res = float(half_res) # переводжу його в НЕ цілочисельний формат

    for_user2 = [] # порожній масив де будуть числа множені на 16, для виведення їх юзеру
    for_user2.append(round(half_res, 3)) # заокруглення (до трьох знаків після коми) чисел, множених на 16 і додання їх в масив
    i = 0
    full_res2 = [] # створюю масив для відповіді
    res3 = half_res * 16 # виконую першу дію множення

    if res3 >= 1: # і першу перевірку: якщо число більше рівне за 1, то:
        res_half = str(res3) # переводжу його в строку
        res_half = res_half.split(".") # розбиваю по крапці на дві частини: до і після крапки
        first = int(res_half[0]) # першу частину (до крапки (тобто цілу)) переводжу в цілочисельний формат
        res3 -= first # віднімаю від основного, так би мовити числа (яке множиться), цілу частину
        if first >= 10: # перевірка чи остача більша рівна за 10, тоді заміняємо її буквою
            first = more10[first]
        full_res2.append(str(first)) # додаю в масив строкою
    else: # протилежний варіант першої перевірки
        full_res2.append('0')

    while i < 7: # продовжую перевірки, заповнюючи масив числами
        for_user2.append(round(res3, 3))
        res3 = res3 * 16

        if res3 >= 1:
            res_half = str(res3)
            res_half = res_half.split(".")
            first = int(res_half[0])
            res3 -= first
            if first >= 10:
                first = more10[first]
            full_res2.append(str(first))
        else:
            full_res2.append('0')
        i += 1




    i = 0
    while i < len(for_user1): # створення виразів для користувача, які він записуватиме (з числом до коми)
        mid = "(" + str(full_res1[i]) + ")"
        print(str(for_user1[i]), ": 16 =", for_user1[i] // 16, mid)
        i += 1

    print("")

    i = 0
    while i < len(for_user2): # створення виразів для користувача, які він записуватиме (з числом після коми)
        res = for_user2[i] * 16

        if res >= 1:
            res_half = str(res)
            res_half = res_half.split(".")
            first = int(res_half[0])
            res -= first
        else:
            pass

        mid = str(for_user2[i]) + " * 16 = " + str(round(res, 3)) + " (" + str(full_res2[i]) + ")"
        print(mid)
        i += 1

    print("")



    full_res1.reverse() # перевертаю масив, щоб числа для відповіді були в правильному порядку
    full_res1 = ''.join(full_res1) # зробив з масива строку до коми
    full_res2 = ''.join(full_res2) # зробив з масива строку після коми
    full_res = full_res1 + "," + full_res2 # формую фінальне число результат




    final = b + "[10] = " + str(full_res) + "[16]" # формую фінальну строку з відповіддю переведення
    print(final)
    print("")
    print("")
    print("")




















def task4(num):

    print("Тема: 4. ЗАЗНАЧЬТЕ МІНІМАЛЬНУ ОСНОВУ СИСТЕМИ ЧИСЛЕННЯ, ДО ЯКОЇ МОЖУТЬ НАЛЕЖАТИ ЗАДАНІ ЧИСЛА")
    print("")
    print("ПОЯСНЕННЯ: Для того, щоб знайти мінімальну основу системи числення, ми повинні знайти найбільшу цифру в числі і збільшити її на 1, як наприклад у двійкових числах найбільша цифра 1, у вісімкових 7 і т.д.")
    print("")

    nums = num.split(" ")
    a = nums[0]
    b = nums[1]
    c = nums[2]
    d = nums[3]
    e = nums[4]




    # ДЛЯ ПЕРШОГО ЧИСЛА
    a_div = list(a)
    a_div.remove(",")

    i = 0
    while i < len(a_div):
        a_div[i] = int(a_div[i])
        i += 1
    n = max(a_div)
    x = n + 1

    final = "Число " + a + " належить до " + str(x) + "-ової системи числення, бо максимальна цифра в числі - це " + str(n) + "."
    print(final)




    # ДЛЯ ДРУГОГО ЧИСЛА
    b_div = list(b)
    b_div.remove(",")

    i = 0
    while i < len(b_div):
        b_div[i] = int(b_div[i])
        i += 1
    n = max(b_div)
    x = n + 1

    final = "Число " + b + " належить до " + str(x) + "-ової системи числення, бо максимальна цифра в числі - це " + str(n) + "."
    print(final)




    # ДЛЯ ТРЕТЬОГО ЧИСЛА
    c_div = list(c)
    c_div.remove(",")

    i = 0
    while i < len(c_div):
        c_div[i] = int(c_div[i])
        i += 1
    n = max(c_div)
    x = n + 1

    final = "Число " + c + " належить до " + str(x) + "-ової системи числення, бо максимальна цифра в числі - це " + str(n) + "."
    print(final)




    # ДЛЯ ЧЕТВЕРТОГО ЧИСЛА
    d_div = list(d)
    d_div.remove(",")

    i = 0
    while i < len(d_div):
        d_div[i] = int(d_div[i])
        i += 1
    n = max(d_div)
    x = n + 1

    final = "Число " + d + " належить до " + str(x) + "-ової системи числення, бо максимальна цифра в числі - це " + str(n) + "."
    print(final)




    # ДЛЯ П'ЯТОГО ЧИСЛА
    e_div = list(e)
    e_div.remove(",")

    i = 0
    while i < len(e_div):
        e_div[i] = int(e_div[i])
        i += 1
    n = max(e_div)
    x = n + 1

    final = "Число " + e + " належить до " + str(x) + "-ової системи числення, бо максимальна цифра в числі - це " + str(n) + "."
    print(final)
    print("")
    print("")
    print("")



















def task5(num):
    # ПЕРЕД ТИМ, ЯК НАДСИЛАТИ ЧИСЛА БОТУ, ТРЕБА ПРИБРАТИ ПРОБІЛИ БІЛЯ МІНУСА І ПЛЮСА (В СУМІ 4 ПРОБІЛА), ЩОБ ПРОБІЛ БУВ ЛИШЕ МІЖ ДВОМА ВИРАЗАМИ
    print("Тема: 5. У ПОДАНИХ АРИФМЕТИЧНИХ ВИРАЗАХ ДЕСЯТКОВІ ЧИСЛА БЕЗ ЗНАКІВ ПЕРЕТВОРІТЬ У ЇХ ДВІЙКОВІ ЕКВІВАЛЕНТИ І ВИКОНАЙТЕ ВІДПОВІДНІ ОПЕРАЦІЇ. ВИКОНАЙТЕ ПЕРЕВІРКУ ОТРИМАНИХ РЕЗУЛЬТАТІВ")
    print("")
    print("ПОПЕРЕДЖЕННЯ: Увага! У квадратних дужках позначається система числення! Не переписуйте квадратних дужок, просто система числення пишеться меншими цифрами!\n")
    nums = num.split(" ")
    a = nums[0]
    b = nums[1]




    # ДЛЯ ПЕРШОЇ ДІЇ
    # ДОДАВАННЯ
    print("1) Дія додавання " + a + ":")
    print("")
    a_divided = a.split("+") # розбиваю першу дію (додавання) на два числа
    a_first = int(a_divided[0]) # перше число
    a_second = int(a_divided[1]) # друге число




    for_user1 = [] # порожній масив де будуть числа ділені на 2, для виведення їх юзеру
    res1 = a_first % 2 # по модулю знаходжу останню цифру відповіді (тобто фінального двійкового першого числа першого виразу)
    res2 = a_first // 2 # ділю без остачі (для наступного ділення по модулю)
    for_user1.append(a_first) # додаю в масив число
    full_res1 = [] # створюю пустий масив з відповіддю (перевернутою)
    full_res1.append(str(res1)) # додаю останню цифру відповіді в масив
    while res2 >= 1: # повторюю дії до кінця
        for_user1.append(res2)
        res1 = res2 % 2
        res2 = res2 // 2
        full_res1.append(str(res1))




    for_user2 = [] # порожній масив де будуть числа ділені на 2, для виведення їх юзеру
    res3 = a_second % 2 # по модулю знаходжу останню цифру відповіді (тобто фінального двійкового другого числа першого виразу)
    res4 = a_second // 2 # ділю без остачі (для наступного ділення по модулю)
    for_user2.append(a_second) # додаю в масив число
    full_res2 = [] # створюю пустий масив з відповіддю (перевернутою)
    full_res2.append(str(res3)) # додаю останню цифру відповіді в масив
    while res4 >= 1: # повторюю дії до кінця
        for_user2.append(res4)
        res3 = res4 % 2
        res4 = res4 // 2
        full_res2.append(str(res3))









    i = 0
    while i < len(for_user1):  # створення виразів для користувача, які він записуватиме (з першим числом першого виразу)
        mid = "(" + str(full_res1[i]) + ")"
        print(str(for_user1[i]), ": 2 =", for_user1[i] // 2, mid)
        i += 1

    print("")

    full_res1.reverse() # перевертаю масив, щоб числа для відповіді були в правильному порядку
    full_res1 = ''.join(full_res1) # зробив з масива строку

    final = str(a_first) + "[10] = " + str(full_res1) + "[2]" # формую фінальну строку з відповіддю переведення
    print(final)
    print("")




    i = 0
    while i < len(for_user2):  # створення виразів для користувача, які він записуватиме (з другим числом першого виразу)
        mid = "(" + str(full_res2[i]) + ")"
        print(str(for_user2[i]), ": 2 =", for_user2[i] // 2, mid)
        i += 1

    print("")

    full_res2.reverse() # перевертаю масив, щоб числа для відповіді були в правильному порядку
    full_res2 = ''.join(full_res2) # зробив з масива строку

    final = str(a_second) + "[10] = " + str(full_res2) + "[2]" # формую фінальну строку з відповіддю переведення
    print(final)
    print("")





    summa = int(full_res1, 2) + int(full_res2, 2) # результат (десятковий) додавання двох двійкових чисел  (після коми стоїть система числення)
    res_bin = bin(summa)[2:] # переведення цього результату в двійкову систему




    # ВИВІД ВИРАЗУ ДОДАВАННЯ ДВІЙКОВИХ ЧИСЕЛ В СТОВПЧИК
    defin1 = len(res_bin) - len(full_res1)
    defin2 = len(res_bin) - len(full_res2)
    print(" " + " " * defin1 + full_res1)
    print("+")
    print(" " + " " * defin2 + full_res2)
    print(" __________")
    print(" " + res_bin)
    print("")





    # ПЕРЕВЕДЕННЯ НАЗАД В ДЕСЯТКОВУ СИСТЕМУ, ЩОБ ПЕРЕВІРИТИ ПРАВИЛЬНІСТЬ ВИКОНАННЯ ДОДАВАННЯ
    res_bin1 = res_bin # присвоюю значення двійкового результату іншій змінній
    res_bin1 = list(str(res_bin1)) # роблю масив (з цифр в виді рядків) з двійкового результату

    res_bin1 = [int(item) for item in res_bin1]  # переводжу масив двійкового результату в цифри з рядків
    res_bin1.reverse()  # перевернув список цифр результату, щоб виконати дії у правильному порядку

    # РАХУЮ СУМУ РЕЗУЛЬТАТУ (В ДЕСЯТКОВІЙ)
    res1 = 0
    i = 0
    while i < len(res_bin1):
        res1 += res_bin1[i] * 2 ** i
        i += 1




    res_bin1.reverse()  # ще раз перевернув список цифр результату, щоб записати в строку в правильному порядку
    str_full_res = ""

    # СТВОРЕННЯ ВИРАЗУ-ПЕРЕВЕДЕННЯ В ДЕСЯТКОВУ З ДВІЙКОВОЇ
    i = 0
    l = len(res_bin1) - 1
    while i < len(res_bin1):
        mid = str(res_bin1[i]) + "*2^" + "(" + str(l) + ")" + " + "
        str_full_res += mid
        i += 1
        l -= 1




    # ДОВЕРШЕННЯ ВИРАЗУ
    str_full_res = str_full_res[:-1]
    str_full_res = str_full_res[:-1]
    str_full_res = str(res_bin) + "[2] = " + str_full_res + "= " + str(res1) + "[10]"

    print(str_full_res)
    print("")



















    # ДЛЯ ДРУГОЇ ДІЇ
    # ВІДНІМАННЯ
    print("2) Дія віднімання " + b + ":")
    print("")
    b_divided = b.split("–") # розбиваю другу дію (віднімання) на два числа
    b_first = int(b_divided[0]) # перше число
    b_second = int(b_divided[1]) # друге число




    for_user1 = [] # порожній масив де будуть числа ділені на 2, для виведення їх юзеру
    res1 = b_first % 2 # по модулю знаходжу останню цифру відповіді (тобто фінального двійкового першого числа першого виразу)
    res2 = b_first // 2 # ділю без остачі (для наступного ділення по модулю)
    for_user1.append(b_first) # додаю в масив число
    full_res1 = [] # створюю пустий масив з відповіддю (перевернутою)
    full_res1.append(str(res1)) # додаю останню цифру відповіді в масив
    while res2 >= 1: # повторюю дії до кінця
        for_user1.append(res2)
        res1 = res2 % 2
        res2 = res2 // 2
        full_res1.append(str(res1))




    for_user2 = [] # порожній масив де будуть числа ділені на 2, для виведення їх юзеру
    res3 = b_second % 2 # по модулю знаходжу останню цифру відповіді (тобто фінального двійкового другого числа першого виразу)
    res4 = b_second // 2 # ділю без остачі (для наступного ділення по модулю)
    for_user2.append(b_second) # додаю в масив число
    full_res2 = [] # створюю пустий масив з відповіддю (перевернутою)
    full_res2.append(str(res3)) # додаю останню цифру відповіді в масив
    while res4 >= 1: # повторюю дії до кінця
        for_user2.append(res4)
        res3 = res4 % 2
        res4 = res4 // 2
        full_res2.append(str(res3))









    i = 0
    while i < len(for_user1):  # створення виразів для користувача, які він записуватиме (з першим числом першого виразу)
        mid = "(" + str(full_res1[i]) + ")"
        print(str(for_user1[i]), ": 2 =", for_user1[i] // 2, mid)
        i += 1

    print("")

    full_res1.reverse() # перевертаю масив, щоб числа для відповіді були в правильному порядку
    full_res1 = ''.join(full_res1) # зробив з масива строку

    final = str(b_first) + "[10] = " + str(full_res1) + "[2]" # формую фінальну строку з відповіддю переведення
    print(final)
    print("")




    i = 0
    while i < len(for_user2):  # створення виразів для користувача, які він записуватиме (з другим числом першого виразу)
        mid = "(" + str(full_res2[i]) + ")"
        print(str(for_user2[i]), ": 2 =", for_user2[i] // 2, mid)
        i += 1

    print("")

    full_res2.reverse() # перевертаю масив, щоб числа для відповіді були в правильному порядку
    full_res2 = ''.join(full_res2) # зробив з масива строку

    final = str(b_second) + "[10] = " + str(full_res2) + "[2]" # формую фінальну строку з відповіддю переведення
    print(final)
    print("")




    # ОБЕРТАЮ ДРУГЕ ЧИСЛО
    full_res2a = full_res2 # присвоюю значення другого числа в двійковій формі іншій змінній, щоб не змінити значення full_res2
    full_res2a = list(full_res2a) # масив зі строки
    i = 0
    while i < len(full_res2a): # обертання (всі одиниці заміняю нулями і навпаки)
        if full_res2a[i] == '1':
            full_res2a[i] = '0'
        else:
            full_res2a[i] = '1'
        i += 1

    i = 0
    while full_res2a[i] == '0': # видаляю усі лишні нулі спочатку нового числа
        full_res2a.pop(i)
        i += 1
    full_res2b = ''.join(full_res2a) # складаю число докупи

    sum = int(full_res2b, 2) + int('1', 2) # додаю 1, щоб з оберненого числа вийшло інвертоване
    full_res2c = bin(sum)[2:]

    if len(full_res2) > len(full_res2c):
        v = len(full_res2) - len(full_res2c)
        full_res2c = v * "0" + full_res2c

    x = max(len(full_res2a), len(full_res2b), len(full_res2c)) # шукаю найдовшу строку-число, щоб знати, які відступи робити для інших чисел

    # ВИВІД ВИРАЗУ ІНВЕРТУВАННЯ
    print("Інвертація другого числа:")
    defin3 = x - len(full_res2)
    print(" " * defin3 + full_res2)
    print("________")
    defin4 = x - len(full_res2b)
    print(" " * defin4 + full_res2b)
    defin5 = x - 1
    print(" " * defin5 + "1")
    print("________")
    defin6 = x - len(full_res2c)
    print(" " * defin6 + full_res2c)
    print("")

    # ВИВІД ВИРАЗУ ДОДАВАННЯ
    print("Додавання до першого числа другого (інвертованого):")

    if len(full_res2c) < len(full_res1):
        p = len(full_res1) - len(full_res2c)
        full_res2c = p * "1" + full_res2c

    print(" 0," + full_res1)
    print("+")
    print(" 1," + full_res2c)
    print("_____________")


    summa = int(full_res1, 2) + int(full_res2c, 2) # результат (десятковий) додавання двох двійкових чисел  (після коми стоїть система числення)
    res_bin = bin(summa)[2:] # переведення цього результату в двійкову систему

    res_bin = res_bin[2:]
    res_bin = list(res_bin)
    if res_bin[0] == "1" and res_bin[1] == "0": # якщо перші два числа результату додавання (у двійковій системі) - це 1 і 0, то забираю їх, щоб дізнатись число результат
        res_bin.pop(0)
        res_bin.pop(1)
    else: # ІНАКШЕ ПІЗДЄЦ (програма розрахована на те, що число вийде додатнім)
        pass
    res_bin = ''.join(res_bin)

    if len(res_bin) < len(full_res1):
        t = len(full_res1) - len(res_bin)
        res_bin = "0" * t + res_bin

    print(" 0," + res_bin) # вивід результату
    print("")





    # ПЕРЕВЕДЕННЯ НАЗАД В ДЕСЯТКОВУ СИСТЕМУ, ЩОБ ПЕРЕВІРИТИ ПРАВИЛЬНІСТЬ ВИКОНАННЯ ДОДАВАННЯ
    res_bin1 = res_bin # присвоюю значення двійкового результату іншій змінній
    res_bin1 = list(str(res_bin1)) # роблю масив (з цифр в виді рядків) з двійкового результату

    res_bin1 = [int(item) for item in res_bin1]  # переводжу масив двійкового результату в цифри з рядків
    res_bin1.reverse()  # перевернув список цифр результату, щоб виконати дії у правильному порядку

    # РАХУЮ СУМУ РЕЗУЛЬТАТУ (В ДЕСЯТКОВІЙ)
    res1 = 0
    i = 0
    while i < len(res_bin1):
        res1 += res_bin1[i] * 2 ** i
        i += 1




    res_bin1.reverse()  # ще раз перевернув список цифр результату, щоб записати в строку в правильному порядку
    str_full_res = ""

    # СТВОРЕННЯ ВИРАЗУ-ПЕРЕВЕДЕННЯ В ДЕСЯТКОВУ З ДВІЙКОВОЇ
    i = 0
    l = len(res_bin1) - 1
    while i < len(res_bin1):
        mid = str(res_bin1[i]) + "*2^" + "(" + str(l) + ")" + " + "
        str_full_res += mid
        i += 1
        l -= 1




    # ДОВЕРШЕННЯ ВИРАЗУ
    str_full_res = str_full_res[:-1]
    str_full_res = str_full_res[:-1]
    str_full_res = str(res_bin) + "[2] = " + str_full_res + "= " + str(res1) + "[10]"

    print(str_full_res)
    print("")
    print("")
    print("")




















def task6(num):

    print("Тема: 6. ПЕРЕТВОРІТЬ ПОСЛІДОВНО ЗА ВКАЗАНОЮ СХЕМОЮ ДЕСЯТКОВЕ ЧИСЛО З ОДНІЄЇ СИСТЕМИ ЧИСЛЕННЯ ДО ІНШОЇ З ТОЧНІСТЮ ДО d^(-4) (d –ОСНОВА СИСТЕМИ ЧИСЛЕННЯ).")
    print("")
    print("ПОПЕРЕДЖЕННЯ: Увага! У квадратних дужках позначається система числення! Не переписуйте квадратних дужок, просто система числення пишеться меншими цифрами!")
    print("")

    b = num

    # ДЛЯ ПЕРШОГО ПЕРЕВЕДЕННЯ
    # ДЛЯ ПЕРЕВЕДЕННЯ В ВІСІМКОВУ СИСТЕМУ ЧИСЛЕННЯ
    print("1) Переведення числа з десяткової системи числення у вісімкову:\n")
    b_divided = b.split(",") # розбиваю число з основою десять на дві частини: цілу (до коми) і дробову (після коми)
    b_before_coma = int(b_divided[0]) # роблю ціле число, з числа до коми
    b_after_coma = int(b_divided[1]) # роблю ціле число з числа після коми



    for_user1 = [] # порожній масив де будуть числа ділені на 8, для виведення їх юзеру
    res1 = b_before_coma % 8 # по модулю знаходжу останню цифру відповіді (тобто фінального вісімкового числа до коми)
    res2 = b_before_coma // 8 # ділю без остачі (для наступного ділення по модулю)
    for_user1.append(b_before_coma) # додаю в масив число
    full_res1 = [] # створюю пустий масив з відповіддю (перевернутою)
    full_res1.append(str(res1)) # додаю останню цифру відповіді в масив
    while res2 >= 1: # повторюю дії до кінця
        for_user1.append(res2)
        res1 = res2 % 8
        res2 = res2 // 8
        full_res1.append(str(res1))




    half_res = "0." + str(b_after_coma) # роблю дробове число після коми строкою
    half_res = float(half_res) # переводжу його в НЕ цілочисельний формат

    for_user2 = [] # порожній масив де будуть числа множені на 8, для виведення їх юзеру
    for_user2.append(round(half_res, 3)) # заокруглення (до трьох знаків після коми) чисел, множених на 8 і додання їх в масив
    i = 0
    full_res2 = [] # створюю масив для відповіді
    res3 = half_res * 8 # виконую першу дію множення

    if res3 >= 1: # і першу перевірку: якщо число більше рівне за 1, то:
        res_half = str(res3) # переводжу його в строку
        res_half = res_half.split(".") # розбиваю по крапці на дві частини: до і після крапки
        first = int(res_half[0]) # першу частину (до крапки (тобто цілу)) переводжу в цілочисельний формат
        res3 -= first # віднімаю від основного так би мовити числа (яке множиться) цілу частину
        full_res2.append(str(first)) # додаю в масив строкою
    else: # протилежний варіант першої перевірки
        full_res2.append('0')

    while i < 3: # продовжую перевірки, заповнюючи масив числами
        for_user2.append(round(res3, 3))
        res3 = res3 * 8

        if res3 >= 1:
            res_half = str(res3)
            res_half = res_half.split(".")
            first = int(res_half[0])
            res3 -= first
            full_res2.append(str(first))
        else:
            full_res2.append('0')
        i += 1




    i = 0
    while i < len(for_user1): # створення виразів для користувача, які він записуватиме (з числом до коми)
        mid = "(" + str(full_res1[i]) + ")"
        print(str(for_user1[i]), ": 8 =", for_user1[i] // 8, mid)
        i += 1

    print("")

    i = 0
    while i < len(for_user2): # створення виразів для користувача, які він записуватиме (з числом після коми)
        res = for_user2[i] * 8

        if res >= 1:
            res_half = str(res)
            res_half = res_half.split(".")
            first = int(res_half[0])
            res -= first
        else:
            pass

        mid = str(for_user2[i]) + " * 8 = " + str(round(res, 3)) + " (" + str(full_res2[i]) + ")"
        print(mid)
        i += 1

    print("")



    full_res1.reverse() # перевертаю масив, щоб числа для відповіді були в правильному порядку
    full_res1 = ''.join(full_res1) # зробив з масива строку до коми
    full_res2 = ''.join(full_res2) # зробив з масива строку після коми
    full_res = full_res1 + "," + full_res2 # формую фінальне число результат




    final = b + "[10] = " + str(full_res) + "[8]" # формую фінальну строку з відповіддю переведення
    print(final)
    print("")










    # ДЛЯ ДРУГОГО ПЕРЕВЕДЕННЯ
    # ДЛЯ ПЕРЕВЕДЕННЯ В ДВІЙКОВУ СИСТЕМУ ЧИСЛЕННЯ
    print("2) Переведення числа з вісімкової системи числення у двійкову:\n")

    b = full_res
    bin_mass = {"0":"000", "1":"001", "2":"010", "3":"011", "4":"100", "5":"101", "6":"110", "7":"111"}

    b_divided = b.split(",") # розбиваю число з основою десять на дві частини: цілу (до коми) і дробову (після коми)
    b_before_coma = list(b_divided[0]) # роблю масив чисел (строкових) з числа до коми
    b_after_coma = list(b_divided[1]) # роблю масив чисел (строкових) з числа після коми
    b_before_coma1 = list(b_divided[0]) # роблю масив чисел (строкових) з числа до коми (щоб зробити з них двійкові)
    b_after_coma1 = list(b_divided[1]) # роблю масив чисел (строкових) з числа після коми (щоб зробити з них двійкові)

    # ПЕРЕВОДЖУ ЧИСЛА ДО КОМИ В ДВІЙКОВІ
    i = 0
    while i < len(b_before_coma):
        b_before_coma1[i] = bin_mass[b_before_coma[i]]
        i += 1

    # ПЕРЕВОДЖУ ЧИСЛА ПІСЛЯ КОМИ В ДВІЙКОВІ
    i = 0
    while i < len(b_after_coma):
        b_after_coma1[i] = bin_mass[b_after_coma[i]]
        i += 1


    # ВИВІД ПРОЦЕДУРИ ПЕРЕВЕДЕННЯ ДО КОМИ
    i = 0
    while i < len(b_before_coma):
        print(b_before_coma[i] + "[10] = " + b_before_coma1[i] + "[2]")
        i += 1
    print("")

    # ВИВІД ПРОЦЕДУРИ ПЕРЕВЕДЕННЯ ПІСЛЯ КОМИ
    i = 0
    while i < len(b_after_coma):
        print(b_after_coma[i] + "[10] = " + b_after_coma1[i] + "[2]")
        i += 1
    print("")

    # СКОАДАЮ ПЕРЕВЕДЕНІ МАСИВИ ДОКУПИ
    b_before_coma1 = ''.join(b_before_coma1)
    b_after_coma1 = ''.join(b_after_coma1)

    # ТАК ЯК З ТОЧНІСТЮ ДО d^(-4) ТРЕБА ПЕРЕВЕСТИ, ТО ВИДАЛЯЮ ВСІ ЛИШНІ ЕЛЕМЕНТИ ПІСЛЯ КОМИ ПІСЛЯ ЧЕТВЕРТОГО
    b_after_coma2 = list(b_after_coma1)
    while len(b_after_coma2) > 4:
        b_after_coma2.pop(4)
    b_after_coma1 = ''.join(b_after_coma2)


    full_res = b_before_coma1 + "," + b_after_coma1 # результат в виді строки

    # РЕЗУЛЬТАТ ВИВОДУ РЕЗУЛЬТАТУ...
    print("Результат з точністю до d^(-4):")
    print(b + "[8] = " + full_res + "[2]") # результат дія
    print("")










    # ДЛЯ ТРЕТЬОГО ПЕРЕВЕДЕННЯ
    # ДЛЯ ПЕРЕВЕДЕННЯ В ШІСТНАДЦЯТКОВУ СИСТЕМУ ЧИСЛЕННЯ
    print("3) Переведення числа з двійкової системи числення у шістнадцяткову:\n")

    b = full_res
    bin_mass = {"0000":"0", "0001":"1", "0010":"2", "0011":"3", "0100":"4", "0101":"5", "0110":"6", "0111":"7", "1000":"8", "1001":"9", "1010":"A", "1011":"B", "1100":"C", "1101":"D", "1110":"E", "1111":"F"}

    b_divided = b.split(",") # розбиваю число з основою два на дві частини: цілу (до коми) і дробову (після коми)
    b_before_coma = b_divided[0] # частина до коми
    b_after_coma = b_divided[1] # частина після коми

    while len(b_before_coma) % 4 != 0: # якщо довжина числа не кратна 4, то додаємо наперід нулі, доки не буде кратна 4 (при цьому величина числа не змінюється)
        b_before_coma = "0" + b_before_coma

    print(b_before_coma + "," + b_after_coma) # вивід цього числа кратного 4
    print("")

    x = len(b_before_coma) / 4 # кількість тетрад у числі
    # СКЛАДНА ПРОЦЕДУРА РОЗБИТТЯ ДВІЙКОВОГО ЧИСЛА НА ТЕТРАДИ
    i = 0
    y1 = 0
    y2 = 4
    res_before_coma = []
    while i < x:
        p = b_before_coma[y1:y2]
        res_before_coma.append(p)
        i += 1
        y1 += 4
        y2 += 4

    # ПЕРЕВОДЖУ ВСІ ТЕТРАДИ З ДВІЙКОВИХ У ШІСТНАДЦЯТКОВІ СИМВОЛИ
    i = 0
    res_before_coma1 = []
    while i < len(res_before_coma):
        res_before_coma1.append(bin_mass[res_before_coma[i]])
        i += 1

    res_after_coma = bin_mass[b_after_coma] # переводжу одну двійкову тетраду після коми у шістнадцятковий символ

    # ВИВІД ПЕРЕВЕДЕННЯ ДВІЙКОВИХ ТЕТРАД У ШІСТНАДЦЯТКОВІ СИМВОЛИ
    i = 0
    while i < len(res_before_coma):
        print(res_before_coma[i] + "[2] = " + res_before_coma1[i] + "[16]")
        i += 1
    print("")
    print(b_after_coma + "[2] = " + res_after_coma + "[16]")
    print("")

    # СКЛАДАННЯ ЧИСЛА-РЕЗУЛЬТАТУ ДО КУПИ
    full_res1 = ''.join(res_before_coma1)
    full_res = full_res1 + "," + res_after_coma

    print(b + "[2] = " + full_res + "[16]")  # результат дія
    print("")









    # ДЛЯ ЧЕТВЕРТОГО ПЕРЕВЕДЕННЯ
    # ДЛЯ ПЕРЕВЕДЕННЯ В ДЕСЯТКОВУ СИСТЕМУ ЧИСЛЕННЯ
    print("4) Переведення числа з шістнадцяткової системи числення у десяткову:\n")

    b = full_res
    bin_mass = {"0":0, "1":1, "2":2, "3":3, "4":4, "5":5, "6":6, "7":7, "8":8, "9":9, "A":10, "B":11, "C":12, "D":13, "E":14, "F":15}

    b_divided = b.split(",") # розбиваю число з основою шістнадцять на дві частини: цілу (до коми) і дробову (після коми)
    b_before_coma = list(b_divided[0]) # частина до коми
    b_after_coma = b_divided[1] # частина після коми

    # РАХУЮ ДЕСЯТКОВЕ ЧИСЛО ДО КОМИ (ОБЕРТАЮ МАСИВ І ДОДАЮ ПРОМІЖНІ РЕЗУЛЬТАТИ (ЧИСЛА ПОМНОЖЕНІ НА 16 В ПЕВНОМУ СТЕПЕНІ))
    b_before_coma.reverse()
    i = 0
    res1 = 0
    while i < len(b_before_coma):
        res1 += bin_mass[b_before_coma[i]] * 16**i
        i += 1

    # РАХУЮ ТАКОЖ РЕЗУЛЬТАТ ПІСЛЯ КОМИ, ОКРУГЛЮЮЧИ ЙОГО ДО 4 ЗНАКИ ПІСЛЯ КОМИ. ДОДАЮ РЕЗУЛЬТАТ ДО І ПІСЛЯ КОМИ І ОТРИМУЮ ФІНАЛЬНИЙ РЕЗУЛЬТАТ
    res2 = bin_mass[b_after_coma] * 16**(-1)
    res2 = round(res2, 4)
    full_res = res1 + res2

    # ОБЕРТАЮ МАСИВ НАЗАД І СТВОРЮЮ СТРОКУ, ЯКУ ОТРИМАЄ КОРИСТУВАЧ (В ЦИКЛІ СТРОКА З СИМВОЛАМИ ДО КОМИ І ЩЕ ПОТІМ ЧАСТИНКА ПІСЛЯ КОМИ)
    b_before_coma.reverse()
    l = len(b_before_coma) - 1
    i = 0
    res_str = ""
    while i < len(b_before_coma):
        res_str += b_before_coma[i] + "*16^(" + str(l) + ") + "
        i += 1
        l -= 1
    res_str += b_after_coma + "*16^(-1) = " + str(full_res)

    # ВИВІД І ПОПЕРЕДЖЕННЯ
    print(res_str)
    print("")
    print("ПОЯСНЕННЯ: Результат подано з точністю до d^(-4). Результат не збігся повністю з початковим числом, бо в процесі переведень, ми подавали число з точністю до d^(-4).")
    print("")
    print("")
    print("")



























def task7(num):

    print("Тема: 7. НОРМАЛІЗУЙТЕ ДВІЙКОВІ ЧИСЛА У ФОРМАТІ З РУХОМОЮ КОМОЮ І ЗАПИШІТЬ ЇХ У НОРМАЛЬНІЙ ФОРМІ:")
    print("")
    print("ПОЯСНЕННЯ: Нормалізоване число - це неціле число, у якого перша цифра після коми - це 1. Якось так :/")
    print("")

    bin_mass = {"0":0, "1":1, "10":2, "11":3, "100":4, "101":5, "110":6, "111":7} # массив для переведення чисел з бінарних в прості
    ten_mass = {0:"0", 1:"1", 2:"10", 3:"11", 4:"100", 5:"101", 6:"110", 7:"111"} # массив для переведення чисел з простих в бінарні
    num = num.split(" ") # розбиваю строку задану юзером на два числа
    a = num[0] # перше число
    b = num[1] # друге число



    # ДЛЯ НОРМАЛІЗАЦІЇ ПЕРШОГО ЧИСЛА
    i = 0
    while i < len(a): # в циклі перевіряю, чи степінь першого числа додатній чи від'ємний
        if a[i] == "-": # якщо від'ємний
            a1 = a.split("-") # розбиваю по мінусу
            numer = a1[0] # перша частинка це число
            numer1 = numer[:-3] # але прибираю зайву частинку (*10)
            power = a1[1] # початковий степінь (бінарний)
            power10 = bin_mass[power] # переводжу початковий степінь з бінарного в простий код

            numer2 = numer1.split(",") # саме число розбиваю по комі
            numer_before_coma = numer2[0] # число до коми
            numer_after_coma = numer2[1] # число після коми

            new_power = -1 * power10 + len(numer_before_coma) # створюю степінь, який буде у відповіді (множу старий степінь на -1, щоб було видно, що він від'ємний і додаю кількість символів до коми)

            res_num = "0," + numer_before_coma + numer_after_coma # створюю число, яке буде у відповіді, тобто фактично пересуваю частину, яка була перед комою, за кому

            value_before = numer1 + " * 10^(-" + power + ")" # початкове число, яке задав користувач, але в правильному форматі (замість, наприклад, "*10-10" буде " * 10^(-10)" і т.д.)

            if new_power < 0: # якщо степінь вийшов від'ємний
                power_value = -1 * new_power # роблю його додатнім (тобто це величина самого степеня)
                real_power = ten_mass[power_value] # по цій величині шукаю бінарний аналог
                value_after = res_num + " * 10^(-" + real_power + ")" # число результат (з від'ємним степенем)
                result = value_before + " = " + value_after # строка результат нормалізації
            else: # якщо степінь вийшов додатній
                real_power = ten_mass[new_power] # шукаю бінарний аналог степеня
                value_after = res_num + " * 10^(+" + real_power + ")" # число результат (з додатнім степенем)
                result = value_before + " = " + value_after # строка результат нормалізації

            print(result) # вивід строки результату нормалізації для першого числа, якщо спочатку степінь спочатку був від'ємним






        elif a[i] == "+":
            a1 = a.split("+") # розбиваю по плюсу
            numer = a1[0] # перша частинка це число
            numer1 = numer[:-3] # але прибираю зайву частинку (*10)
            power = a1[1] # початковий степінь (бінарний)
            power10 = bin_mass[power] # переводжу початковий степінь з бінарного в простий код

            numer2 = numer1.split(",") # саме число розбиваю по комі
            numer_before_coma = numer2[0] # число до коми
            numer_after_coma = numer2[1] # число після коми

            new_power = power10 + len(numer_before_coma) # створюю степінь, який буде у відповіді (до початкового степеня додаю кількість символів до коми)

            res_num = "0," + numer_before_coma + numer_after_coma # створюю число, яке буде у відповіді, тобто фактично пересуваю частину, яка була перед комою, за кому

            value_before = numer1 + " * 10^(+" + power + ")" # початкове число, яке задав користувач, але в правильному форматі (замість, наприклад, "*10+10" буде " * 10^(+10)" і т.д.)

            real_power = ten_mass[new_power] # шукаю бінарний аналог степеня
            value_after = res_num + " * 10^(+" + real_power + ")" # число результат (з додатнім степенем)
            result = value_before + " = " + value_after # строка результат нормалізації

            print(result) # вивід строки результату нормалізації для першого числа, якщо спочатку степінь спочатку був додатнім

        else:
            pass

        i += 1

    print("")










    # ДЛЯ НОРМАЛІЗАЦІЇ ДРУГОГО ЧИСЛА
    i = 0
    while i < len(b): # в циклі перевіряю, чи степінь першого числа додатній чи від'ємний

        if b[i] == "+": # якщо додатній
            b1 = b.split(",") # розбиваю по комі
            b2 = b1[1] # беру все що після коми (а нуль, що був до коми посилаю за росіським кораблем)

            b3 = b2.split("+") # все що після коми розбиваю по плюсу
            numer = b3[0] # частина до плюса - це наше число, але з залишком (*10)
            numer = numer[:-3] # прибираю залишок (*10)
            power = b3[1] # частина після плюса (початковий степінь)

            n = 0
            while numer[n] == "0": # рахую, скільки є зайвих нулів після коми, які треба буде прибрати
                n += 1

            new_numer = numer[n:] # прибираю нулі з початку числа

            new_power = bin_mass[power] - n # рахую новий степінь в десятковому коді

            if new_power < 0: # якщо новий степінь вийшов від'ємним
                value_power = -1 * new_power # знаходжу його значення степеня
                bin_new_power = ten_mass[value_power] # по його значенню знаходжу двійковий аналог
                print("0," + numer + " * 10^(+" + power + ") = 0," + new_numer + " * 10^(-" + bin_new_power + ")") # складаю строку результат (число спочатку було з додатнім степенем, а стало з від'ємним)
            else: # якщо новий степінь вийшов додатнім
                bin_new_power = ten_mass[new_power] # знаходжу двійковий аналог степеня
                print("0," + numer + " * 10^(+" + power + ") = 0," + new_numer + " * 10^(+" + bin_new_power + ")") # складаю строку результат (число як було з додатнім степенем, так і залишилось)





        elif b[i] == "-":
            b1 = b.split(",")  # розбиваю по комі
            b2 = b1[1]  # беру все що після коми (а нуль, що був до коми посилаю за росіським кораблем)

            b3 = b2.split("-")  # все що після коми розбиваю по мінусу
            numer = b3[0]  # частина до мінуса - це наше число, але з залишком (*10)
            numer = numer[:-3]  # прибираю залишок (*10)
            power = b3[1]  # частина після мінуса (початковий степінь)

            n = 0
            while numer[n] == "0":  # рахую, скільки є зайвих нулів після коми, які треба буде прибрати
                n += 1

            new_numer = numer[n:]  # прибираю нулі з початку числа

            new_power = -1 * bin_mass[power] - n  # рахую новий степінь в десятковому коді

            value_power = -1 * new_power  # знаходжу величину степеня
            bin_new_power = ten_mass[value_power]  # по його величині знаходжу двійковий аналог
            print("0," + numer + " * 10^(+" + power + ") = 0," + new_numer + " * 10^(-" + bin_new_power + ")")  # складаю строку результат (число як було з від'ємним степенем, так і залишилось)





        else:
            pass

        i += 1

    print("")
    print("")
    print("")






























def task8(num):

    print("Тема: 8. ДОДАТИ У ДОПОВНЯЛЬНОМУ ТА ОБЕРНЕНОМУ КОДАХ ДВІЙКОВІ ЧИСЛА У ФОРМАТІ З ФІКСОВАНОЮ КОМОЮ:")
    print("")
    print("ПОПЕРЕДЖЕННЯ: Увага! У цьому завданні у квадаратних дужках позначається, у якому коді подане число:\nпр - прямий;\nоб - обернений;\nдоп - доповняльний.\nКвадратних дужок переписувати не потрібно, просто вкажіть тип двійкового коду трохи меншими буквами.")
    print("")
    num = num.split(" ") # розбиваю задану юзером строку на два числа
    a = num[0]
    b = num[1]

    print("Задані числа:")
    print(a)
    print(b)
    print("")

    # РОЗБИВАЮ ОБИДВА ЧИСЛА НА ДВІ ЧАСТИНИ ПО КОМІ, ЗАЛИШАЮ ЛИШЕ САМЕ ЧИСЛО (ТОБТО ТЕ, ЩО ПІСЛЯ КОМИ)
    a1 = a.split(",")
    b1 = b.split(",")
    a2 = a1[1]
    b2 = b1[1]

    print("Задані числа у прямому коді:")
    print("A[пр] = 11," + a2)
    print("B[пр] = 00," + b2)
    print("")

    # ОБЕРТАЮ ЧИСЛА (ЗАМІНЯЮ 1 НА 0 І НАВПАКИ У ЦИКЛІ), А ДАЛІ СКЛАДАЮ ДОКУПИ (ЦЕ ВСЕ ЛИШЕ ДЛЯ ПЕРШОГО ЧИСЛА, ДРУГЕ НЕ ЧІПАЮ)
    a3 = []
    i = 0
    while i < len(a2):
        if a2[i] == "0":
            a3.append("1")
        else:
            a3.append("0")
        i += 1

    b3 = b2
    a4 = ''.join(a3)
    b4 = ''.join(b3)

    print("Задані числа у оберненому коді:")
    print("A[об] = 11," + a4)
    print("B[об] = 00," + b4)
    print("")

    # ПЕРЕТВОРЮЮ ЧИСЛА У ДОПОВНЯЛЬНИЙ КОД (ДО ПЕРШОГО ЧИСЛА ДОДАЮ ОДИНИЦЮ, ТА Й ВСЕ) (ЦЕ ВСЕ ЛИШЕ ДЛЯ ПЕРШОГО ЧИСЛА, ДРУГЕ НЕ ЧІПАЮ)
    sum = int(a4, 2) + int('1', 2)
    a5 = bin(sum)[2:]
    if len(a5) < 6:
        a5 = (6 - len(a5)) * "0" + a5
    b5 = b4

    print("Задані числа у доповняльному коді:")
    print("A[доп] = 11," + a5)
    print("B[доп] = 00," + b5)
    print("")





    a6 = "11" + a4
    b6 = "00" + b4
    sum = int(a6, 2) + int(b6, 2) # додаю числа в оберених кодах
    half_res = bin(sum)[2:]

    n = len(half_res) - 6 # рахую скільки символів лишилось до коми (3 - якщо 110, 2 - якщо 11)
    full_res = half_res[n:] # відділяю лише саме число

    print("1) Додавання чисел у обернених кодах:")
    print("A[об] + B[об] = C[об]")
    print("")
    print(" 11," + a4)
    print("+")
    print(" 00," + b4)
    print("__________")
    if n == 2: # в залежності від символів до коми виводжу відповідь
        print(" 11," + full_res)
    else:  # протилежний варіант
        print("110," + full_res)
    print("")
    print("C[об] = 11," + full_res)
    full_res1 = []
    i = 0
    while i < len(full_res): # перевід результату з оберненого коду в прямий
        if full_res[i] == "0":
            full_res1.append("1")
        else:
            full_res1.append("0")
        i += 1
    full_res1 = ''.join(full_res1) # складання результату докупи
    print("C[пр] = 11," + full_res1)
    print("")





    # ВСІ ТІ САМІ ДІЇ ДЛЯ ДОДАВАННЯ В ДОПОВНЯЛЬНИХ КОДАХ, АЛЕ ВЖЕ НЕ РАХУЮ РЕЗУЛЬТАТ В ПРЯМОМУ КОДІ, БО ВІН ТАКИЙ САМИЙ, ЯК І ВИЩЕ
    a7 = "11" + a5
    b7 = "00" + b5
    sum = int(a7, 2) + int(b7, 2)
    half_res = bin(sum)[2:]

    n = len(half_res) - 6
    full_res = half_res[n:]

    print("2) Додавання чисел у доповняльних кодах:")
    print("A[доп] + B[доп] = C[доп]")
    print("")
    print(" 11," + a5)
    print("+")
    print(" 00," + b5)
    print("__________")
    if n == 2:
        print(" 11," + full_res)
    else:
        print("110," + full_res)
    print("")
    print("C[доп] = 11," + full_res)
    print("C[пр] = 11," + full_res1)
    print("")
    print("")
    print("")































def task9(num):
    print("Тема: 9. ДОДАТИ У МОДИФІКОВАНОМУ ДОПОВНЯЛЬНОМУ КОДІ ДВІЙКОВІ ЧИСЛА У ФОРМАТІ З РУХОМОЮ КОМОЮ З ОСНОВОЮ d=2:")
    print("")
    print("ПОПЕРЕДЖЕННЯ: Увага! У цьому завданні у квадаратних дужках позначається, у якому коді подане число:\nпр - прямий;\nоб - обернений;\nдоп - доповняльний.\nКвадратних дужок переписувати не потрібно, просто вкажіть тип двійкового коду трохи меншими буквами.")
    print("")
    bin_mass = {"0":0, "1":1, "10":2, "11":3, "100":4, "101":5, "110":6, "111":7}  # массив для переведення чисел з бінарних в прості
    ten_mass = {0:"0", 1:"1", 2:"10", 3:"11", 4:"100", 5:"101", 6:"110", 7:"111"}  # массив для переведення чисел з простих в бінарні
    num = num.split(" ") # розбиваю задану користувачем строку на дві частини
    a = num[0]
    b = num[1]

    a1 = a.split(",") # кожне число розбиваю по комі, і беру лише те, що після коми
    b1 = b.split(",")
    a1 = a1[1]
    b1 = b1[1]

    a1 = a1.split("*10") # тепер розбиваю по таким трьом символам, щоб розділити степінь і число
    b1 = b1.split("*10")
    a2 = a1[0] # число
    b2 = b1[0]
    a3 = a1[1] # степінь
    b3 = b1[1]

    print("Задані числа:")
    print("A = -0," + a2 + " * 10^(" + a3 + ")")
    print("B = -0," + b2 + " * 10^(" + b3 + ")")

    a4 = a3[1:] # величина степеня
    b4 = b3[1:]

    if a4[0] == "0": # якщо степінь записаний в умові так: 010, то прибираю перший нуль, бо інакше не знайду його десяткову величину в масиві
        a4 = a4[1:]
    if b4[0] == "0":
        b4 = b4[1:]

    if a3[0] == "+": # якщо степінь додатній у двійковому, то додатній і в десятковому, якщо від'ємний, то від'ємний
        a5 = bin_mass[a4]
    else:
        a5 = -1 * bin_mass[a4]

    if b3[0] == "+":
        b5 = bin_mass[b4]
    else:
        b5 = -1 * bin_mass[b4]





    if a5 > b5: # найважливіша частина: визначення більшого з двох степенів (тут перевіряю чи а більше b)
        dis = a5 - b5 # на скільки більший більший степінь
        new_b = "0" * dis + b2 # посуваю число, так би мовити, вправо

        print("ПОЯСНЕННЯ: Щоб зрозуміти, на скільки посунути число з меншим степенем вправо, треба знайти, на скільки його степінь менший за степінь другого числа.")

        print(" (" + a3 + ")") # виводжу вираз знаходження різниці степенів
        print("-")
        print(" (" + b3 + ")")
        print(" ______")
        print(" (+" + ten_mass[dis] + ")")
        print("")

        print("B = -0," + new_b + " * 10^(" + a3 + ")") # виводжу нову В
        print("")

        print("Переведення чисел в доповняльний код:")

        i = 0 # переведення в доповняльний код А
        a6 = []
        while i < len(a2):
            if a2[i] == "0":
                a6.append("1")
            else:
                a6.append("0")
            i += 1
        a6 = ''.join(a6)

        sum = int(a6, 2) + int("1", 2)
        a6 = bin(sum)[2:]

        if len(a6) < 6: # якщо результат вийшов довжино менше 6, то додаю наперід потрібну кількість нулів
            n = 6 - len(a6)
            a6 = "0" * n + a6





        i = 0 # переведення в доповняльний код В
        b6 = []
        while i < len(new_b):
            if new_b[i] == "0":
                b6.append("1")
            else:
                b6.append("0")
            i += 1
        b6 = ''.join(b6)

        sum = int(b6, 2) + int("1", 2)
        b6 = bin(sum)[2:]





        print("A[доп] = 11," + a6)
        print("B[доп] = 11," + b6)
        print("")





        a7 = "11" + a6 + "0" * dis # підготовка чисел для додавання
        b7 = "11" + b6
        sum = int(a7, 2) + int(b7, 2) # додавання
        result = bin(sum)[2:]

        result_aft_coma = result[:3] # розбиваю результат на знак і саме число
        result_bef_coma = result[3:]

        print("Додавання чисел у доповняльних кодах:")
        print("A[доп] + B[доп] = C[доп]")
        print("")
        print("  11," + a6)
        print("+")
        print("  11," + b6)
        print(" __________" + "_" * dis)
        print(" " + result_aft_coma + "," + result_bef_coma)
        print("")
        print("C[доп] = " + result_aft_coma + "," + result_bef_coma)
        print("")
        print("Переведення результату додавання у прямий код:")

        if result_aft_coma == "110": # якщо результат вийшов додатнім, то одразу виводжу, бо пр = доп
            new_res = result_bef_coma
            print("C[пр] = 11," + new_res)
        else: # якщо результат вийшов від'ємним
            i = 0
            new_res = []
            while i < len(result_bef_coma): # переводжу з доповняльного в прямий код
                if result_bef_coma[i] == "0":
                    new_res.append("1")
                else:
                    new_res.append("0")
                i += 1
            new_res = ''.join(new_res)

            sum = int(new_res, 2) + int("1", 2)
            new_res = bin(sum)[2:]

            print("C[пр] = 11," + new_res) # а тоді виводжу

        print("Відповідь:")
        print("C = -0," + new_res + " * 10^(" + a3 + ")")










    else: # всі ті самі дії, що вище, але для протилежного випадку, тобто, якщо степінь В більший
        dis = b5 - a5
        new_a = "0" * dis + a2

        print("ПОЯСНЕННЯ: Щоб зрозуміти, на скільки посунути число з меншим степенем вправо, треба знайти, на скільки його степінь менший за степінь другого числа.")

        print(" (" + a3 + ")")
        print("-")
        print(" (" + b3 + ")")
        print(" ______")
        print(" (+" + ten_mass[dis] + ")")
        print("")

        print("А = -0," + new_a + " * 10^(" + b3 + ")")
        print("")

        print("Переведення чисел в доповняльний код:")

        i = 0
        b6 = []
        while i < len(b2):
            if b2[i] == "0":
                b6.append("1")
            else:
                b6.append("0")
            i += 1
        b6 = ''.join(b6)

        sum = int(b6, 2) + int("1", 2)
        b6 = bin(sum)[2:]

        if len(b6) < 6:
            n = 6 - len(b6)
            b6 = "0" * n + b6

        i = 0
        a6 = []
        while i < len(new_a):
            if new_a[i] == "0":
                a6.append("1")
            else:
                a6.append("0")
            i += 1
        a6 = ''.join(a6)

        sum = int(a6, 2) + int("1", 2)
        a6 = bin(sum)[2:]

        print("A[доп] = 11," + a6)
        print("B[доп] = 11," + b6)
        print("")

        b7 = "11" + b6 + "0" * dis
        a7 = "11" + a6
        sum = int(b7, 2) + int(a7, 2)
        result = bin(sum)[2:]

        result_aft_coma = result[:3]
        result_bef_coma = result[3:]

        print("Додавання чисел у доповняльних кодах:")
        print("A[доп] + B[доп] = C[доп]")
        print("")
        print("  11," + a6)
        print("+")
        print("  11," + b6)
        print(" __________" + "_" * dis)
        print(" " + result_aft_coma + "," + result_bef_coma)
        print("")
        print("C[доп] = " + result_aft_coma + "," + result_bef_coma)
        print("")
        print("Переведення результату додавання у прямий код:")

        if result_aft_coma == "110":
            new_res = result_bef_coma
            print("C[пр] = 11," + new_res)
        else:
            i = 0
            new_res = []
            while i < len(result_bef_coma):
                if result_bef_coma[i] == "0":
                    new_res.append("1")
                else:
                    new_res.append("0")
                i += 1
            new_res = ''.join(new_res)

            sum = int(new_res, 2) + int("1", 2)
            new_res = bin(sum)[2:]

            print("C[пр] = 11," + new_res)

        print("Відповідь:")
        print("C = -0," + new_res + " * 10^(" + b3 + ")")

























task1("Що прийнято називати основою системи числення:") # task1("Яка максимальна кількість розрядів необхідна для представлення результату додавання двох 10-розрядних чисел?")
task2("2712,663 134,223 110001110010101,10111001") # task2("2756,475 433,334 110110111101011,01111101")
task3("56,455 2343167,64") # task3("89,642 4765442,273")
task4("315,783 317712,56 123321,21 1010,10201 3456,345609") # task4("352144,21521 346327,33 324223,821 21111,211 327452,295")
task5("275+333 426–222") # task5("353+254 392–276")
task6("295,4301") # task6("299,1405")
task7("1010,11011*10+11 0,00001001*10+101") # task7("1101,10001*10-101 0,0011011*10+110")
task8("А=-0,101010 В=+0,000111") # task8("А=-0,111011 В=+0,001110")
task9("А=-0,101010*10-101 В=-0,000111*10-011") # task9("А=-0,111011*10+101 В=-0,101001*10-010")

































































# from docx import Document
#
# document = Document()
#
# def func(num):
#     res = num * 123
#     i = 0
#     while i < 10:
#         document.add_paragraph(str(res))
#
#     i += 1
#
# x = input("Enter num: ")
# y = input("Enter variant: ")
#
# s = "rgr_numer_" + str(y) + ".docx"
#
# document.save(s)